# 域名遷移與功能優化指南

## 一、域名遷移注意事項（新版前端 → 舊版域名）

### 1.1 後端需要修改的地方

#### ✅ CORS 配置
**文件**: `ReelMindbackend-main/app.py`

**需要修改的位置**:
```python
# 第 3300-3347 行：CORS 配置
cors_origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:8080",
    "http://127.0.0.1:8080",
    # ⚠️ 可以移除或保留（如果不再使用）
    "https://reelmindv2.zeabur.app",  # 舊版前端（開發階段，未來會遷移到舊版域名）
    # ✅ 確保這個域名在列表中
    "https://reelmind.aijob.com.tw",  # 舊版前端（生產環境，未來統一使用此域名）
    "https://admin.aijob.com.tw",  # 後台管理系統
]

# 強制添加的域名列表（第 3311-3318 行）
required_origins = [
    # ⚠️ 可以移除
    "https://reelmindv2.zeabur.app",  # 新版前端（開發階段）
    # ✅ 確保這個域名在列表中
    "https://reelmind.aijob.com.tw",   # 舊版前端（生產環境）
]
```

**建議操作**:
1. 保留 `https://reelmindv2.zeabur.app` 一段時間（過渡期），確保舊用戶可以正常使用
2. 確認 `https://reelmind.aijob.com.tw` 在 CORS 列表中
3. 過渡期後（例如 1-2 週），可以移除 `reelmindv2.zeabur.app`

#### ✅ OAuth 回調 URL
**文件**: `ReelMindbackend-main/app.py`

**需要修改的位置**:
```python
# 第 449 行
GOOGLE_REDIRECT_URI_NEW = os.getenv("GOOGLE_REDIRECT_URI_NEW", "https://reelmindv2.zeabur.app/oauth/callback")
# ⚠️ 需要改為：
GOOGLE_REDIRECT_URI_NEW = os.getenv("GOOGLE_REDIRECT_URI_NEW", "https://reelmind.aijob.com.tw/oauth/callback")
```

**重要**: 同時需要在 **Google Cloud Console** 中更新授權的重定向 URI：
1. 前往 [Google Cloud Console](https://console.cloud.google.com/)
2. 選擇對應的 OAuth 2.0 客戶端 ID
3. 在「已授權的重定向 URI」中添加：`https://reelmind.aijob.com.tw/oauth/callback`
4. 可以保留舊的 URI 一段時間（過渡期）

#### ✅ 環境變數設定
**需要更新的環境變數**:
```bash
# 後端環境變數
FRONTEND_BASE_URL=https://reelmind.aijob.com.tw
GOOGLE_REDIRECT_URI_NEW=https://reelmind.aijob.com.tw/oauth/callback
ECPAY_RETURN_URL=https://reelmind.aijob.com.tw/payment-result.html
CLIENT_BACK_URL=https://reelmind.aijob.com.tw/payment-result.html
```

#### ✅ 支付回調 URL
**文件**: `ReelMindbackend-main/app.py`

**需要檢查的位置**:
- 第 546 行：`ECPAY_RETURN_URL`
- 第 548 行：`CLIENT_BACK_URL`
- 第 9882-9911 行：支付訂單建立時的 URL 構建邏輯

**建議**: 這些應該已經使用環境變數，確保環境變數正確設定即可。

### 1.2 前端需要修改的地方

#### ✅ API 基礎 URL
**文件**: `V2ReelMindfronted-main/client/src/lib/api-config.ts`

**檢查內容**:
```typescript
// 確認 API_BASE_URL 指向正確的後端
export const API_BASE_URL = process.env.VITE_API_BASE_URL || 'https://api.aijob.com.tw';
```

#### ✅ 前端部署配置
**需要檢查的配置文件**:
- `vercel.json` / `netlify.toml` / `_redirects`（根據部署平台）
- 確保所有路由正確重定向到 `index.html`

### 1.3 遷移檢查清單

- [ ] **後端 CORS 配置**：確認新域名在允許列表中
- [ ] **OAuth 回調 URL**：更新後端環境變數和 Google Cloud Console
- [ ] **支付回調 URL**：確認 ECPay 後台設定正確
- [ ] **環境變數**：更新所有相關環境變數
- [ ] **DNS 設定**：確保新域名正確指向前端服務器
- [ ] **SSL 憑證**：確保新域名有有效的 SSL 憑證
- [ ] **測試 OAuth 登入**：確認 Google 登入功能正常
- [ ] **測試支付流程**：確認支付功能正常
- [ ] **測試 API 調用**：確認所有 API 請求正常
- [ ] **過渡期監控**：保留舊域名一段時間，監控錯誤日誌

---

## 二、使用統計優化建議

### 2.1 當前功能

✅ **已實現**:
- 今日/本週/本月總計
- 趨勢圖表（AreaChart）
- 總計統計（腳本、生成記錄、對話記錄）
- AI 智能分析（在 Statistics 頁面）

### 2.2 優化建議

#### 📊 **1. 增加更多視覺化圖表**

**建議添加**:
- **圓餅圖**：功能使用分布（IP人設規劃 vs 一鍵生成）
- **柱狀圖**：平台使用統計（TikTok、Instagram 等）
- **熱力圖**：使用時段分析（一天中哪些時段最活躍）
- **折線圖**：長期趨勢（過去 30 天/90 天的使用趨勢）

**實現位置**: `V2ReelMindfronted-main/client/src/pages/Statistics.tsx`

#### 📈 **2. 增加對比分析**

**建議添加**:
- **週期對比**：本週 vs 上週、本月 vs 上月
- **成長率**：使用量成長百分比
- **目標追蹤**：設定目標並追蹤達成率

#### 🎯 **3. 增加個人化洞察**

**建議添加**:
- **最佳創作時段**：分析用戶最活躍的時間
- **最常用功能**：統計用戶最常使用的功能
- **內容類型偏好**：分析用戶最常創作的主題類型
- **效率分析**：平均每次創作的時間和產出量

#### 📱 **4. 增加導出功能**

**建議添加**:
- **PDF 報告**：生成月度/年度使用報告
- **CSV 匯出**：匯出詳細數據用於分析
- **分享功能**：分享統計報告到社交媒體

### 2.3 使用說明功能

**建議實現**:
1. **在統計頁面添加「使用說明」按鈕**（類似 Mode1 和 UserDB）
2. **說明內容**:
   - 統計數據的含義
   - 如何解讀圖表
   - 如何設定目標
   - 如何使用 AI 分析

**實現範例**:
```typescript
// 在 Statistics.tsx 中添加
const [showInstructions, setShowInstructions] = useState(false);

// 在導航欄添加按鈕
<Button
  variant="ghost"
  size="icon"
  onClick={() => setShowInstructions(true)}
>
  <HelpCircle className="w-5 h-5" />
</Button>

// 添加 Dialog
<Dialog open={showInstructions} onOpenChange={setShowInstructions}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>使用統計說明</DialogTitle>
    </DialogHeader>
    <div className="space-y-4">
      <div>
        <h3 className="font-semibold mb-2">📊 統計數據說明</h3>
        <ul className="text-sm space-y-1 text-muted-foreground">
          <li>• <strong>今日/本週/本月</strong>：顯示對應時間範圍內的總使用次數</li>
          <li>• <strong>趨勢圖表</strong>：顯示使用量的變化趨勢</li>
          <li>• <strong>總計統計</strong>：顯示累積的腳本、生成記錄和對話記錄數量</li>
        </ul>
      </div>
      <div>
        <h3 className="font-semibold mb-2">🎯 如何設定目標</h3>
        <p className="text-sm text-muted-foreground">
          您可以根據歷史數據設定合理的創作目標，系統會自動追蹤您的進度。
        </p>
      </div>
      <div>
        <h3 className="font-semibold mb-2">🤖 AI 智能分析</h3>
        <p className="text-sm text-muted-foreground">
          點擊「AI 分析」按鈕，系統會使用 AI 分析您的使用數據，提供個人化的創作建議。
        </p>
      </div>
    </div>
  </DialogContent>
</Dialog>
```

---

## 三、推薦碼生成機制

### 3.1 當前理解確認

✅ **您的理解正確**：
- **首次登入 = 註冊**：因為使用 Google OAuth，沒有傳統的「註冊」流程
- **推薦碼生成時機**：用戶首次登入時自動生成推薦碼
- **推薦碼格式**：基於 `user_id` 生成，確保唯一性和穩定性

### 3.2 推薦碼生成邏輯（需要實現）

**建議實現方式**:

```python
# 在用戶首次登入時生成推薦碼
def generate_referral_code(user_id: str) -> str:
    """
    生成穩定的推薦碼
    使用 user_id 的 hash，確保每次生成相同
    """
    import hashlib
    
    # 使用 user_id 生成固定 hash
    hash_obj = hashlib.md5(user_id.encode())
    hash_hex = hash_obj.hexdigest()
    
    # 取前 8 位大寫字母數字組合
    code = hash_hex[:8].upper()
    
    return code

# 在 OAuth 登入成功後調用
@app.post("/api/auth/google-new")
async def google_oauth_new(request: Request):
    # ... 現有的 OAuth 邏輯 ...
    
    # 檢查是否為新用戶（首次登入）
    if is_new_user:
        # 生成推薦碼
        referral_code = generate_referral_code(new_user_id)
        
        # 儲存到資料庫
        save_referral_code(new_user_id, referral_code)
    
    # ... 繼續登入流程 ...
```

### 3.3 推薦碼使用流程

1. **新用戶點擊推薦連結**：`https://reelmind.aijob.com.tw/#/?ref=5CB97639`
2. **前端儲存推薦碼**：儲存到 `localStorage` 或 `cookie`
3. **用戶登入**：使用 Google OAuth 登入
4. **後端檢查推薦碼**：如果存在推薦碼，記錄推薦關係
5. **發放獎勵**：給推薦人發放 7 天免費試用延長

---

## 四、推薦通知系統

### 4.1 通知類型

#### 🔔 **1. 站內通知系統**

**需要實現**:
- **數據庫表**：`notifications`
- **API 端點**：`GET /api/user/notifications`
- **前端組件**：通知中心（類似郵件圖標，顯示未讀數量）

**數據庫結構**:
```sql
CREATE TABLE IF NOT EXISTS notifications (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    type TEXT NOT NULL,  -- 'referral_success', 'reward_granted', 'milestone_achieved'
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    is_read INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user_profiles (user_id)
);
```

**通知內容範例**:
- **推薦成功**：`"🎉 推薦成功！您的好友已成功註冊，您獲得 7 天免費試用延長！"`
- **訂閱獎勵**：`"🎊 恭喜！您的好友完成首次訂閱，您獲得額外 30 天使用期限！（注意：此獎勵與里程碑獎勵為二選一，先達到條件者優先發放）"`
- **里程碑達成**：`"🏆 恭喜達成里程碑！您已成功邀請 5 位付費用戶（月付或年付），獲得 1 個月免費使用！（注意：此獎勵與訂閱獎勵為二選一，先達到條件者優先發放）"`

#### 🍞 **2. Toast 通知**

**實現方式**:
- **觸發時機**：獎勵發放時立即顯示
- **顯示次數**：只顯示一次（使用 `localStorage` 記錄已顯示的通知）
- **顯示位置**：頁面右上角（使用 `sonner` toast）

**實現範例**:
```typescript
// 在發放獎勵後調用
const showRewardToast = (rewardType: string, amount: number) => {
  const toastKey = `reward_${rewardType}_${Date.now()}`;
  const hasShown = localStorage.getItem(toastKey);
  
  if (!hasShown) {
    toast.success('🎉 推薦獎勵已發放！', {
      description: `您獲得 ${amount} 天免費使用期限`,
      duration: 5000,
    });
    localStorage.setItem(toastKey, 'true');
  }
};
```

#### 📧 **3. Email 通知**

**需要實現**:
- **Email 服務**：使用 SendGrid、AWS SES 或類似服務
- **Email 模板**：設計美觀的 HTML 郵件模板
- **發送時機**：獎勵發放時異步發送

**Email 內容範例**:
```html
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
    .content { padding: 30px; background: #f9fafb; }
    .button { display: inline-block; padding: 12px 24px; background: #667eea; color: white; text-decoration: none; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🎉 推薦成功！</h1>
    </div>
    <div class="content">
      <p>親愛的用戶，</p>
      <p>恭喜您！您的好友已成功註冊 ReelMind，您獲得 <strong>7 天免費試用延長</strong>！</p>
      <p>繼續邀請好友，獲得更多獎勵：</p>
      <ul>
        <li>每成功邀請一位好友註冊 → 7 天免費試用延長（無限制）</li>
        <li><strong>二選一獎勵（擇一發放，先達到條件者優先）：</strong></li>
        <li style="margin-left: 20px;">• 好友完成首次訂閱 → 額外 30 天使用期限（每個被推薦用戶只能觸發一次）</li>
        <li style="margin-left: 20px;">• 累積邀請 5 位付費用戶（必須完成付費訂閱，月付或年付均可）→ 1 個月免費使用（每個推薦人只能獲得一次）</li>
        <li style="font-size: 12px; color: #666; margin-top: 8px;">※ 注意：兩個獎勵為二選一，先達到條件者優先發放，已發放過的獎勵不會重複發放</li>
      </ul>
      <a href="https://reelmind.aijob.com.tw/#/profile?tab=referral" class="button">查看推薦統計</a>
    </div>
  </div>
</body>
</html>
```

### 4.2 通知系統實現優先級

**第一階段（核心功能）**:
1. ✅ Toast 通知（最簡單，立即實現）
2. ✅ 站內通知系統（數據庫 + API + 前端組件）

**第二階段（進階功能）**:
3. ⏳ Email 通知（需要配置 Email 服務）

---

## 五、推薦獎勵機制詳細說明

### 5.1 獎勵類型

#### 🎁 **1. 註冊獎勵（7 天免費試用延長）**
- **觸發條件**：被推薦用戶完成首次登入（註冊）
- **獎勵內容**：推薦人獲得 7 天免費試用延長
- **限制**：**無限制**（每成功邀請一位好友都可以獲得）

#### 🎊 **2. 訂閱獎勵（30 天使用期限）與 🏆 3. 里程碑獎勵（1 個月免費使用）— 二選一機制**

**重要說明**：這兩個獎勵為**二選一**，先達到條件者優先發放，已發放過的獎勵不會重複發放。

**獎勵 A：訂閱獎勵（30 天使用期限）**
- **觸發條件**：被推薦用戶完成首次訂閱
- **獎勵內容**：推薦人獲得額外 30 天使用期限
- **限制**：
  - **每個被推薦用戶只能觸發一次**（即使被推薦用戶後續再次訂閱，也不會重複發放）
  - **如果推薦人已經獲得過里程碑獎勵（1個月免費），則不再發放此獎勵**（二選一機制）

**獎勵 B：里程碑獎勵（1 個月免費使用）**
- **觸發條件**：推薦人累積邀請 **5 位付費用戶**（必須完成付費訂閱，月付或年付均可）
- **獎勵內容**：推薦人獲得 1 個月（30 天）免費使用
- **限制**：
  - **每個推薦人只能獲得一次**（達到 5 位付費用戶後發放，之後即使再邀請更多好友也不會重複發放）
  - **如果推薦人已經獲得過訂閱獎勵（30天），則不再發放此獎勵**（二選一機制）
- **重要**：
  - 只有當被推薦的好友完成**付費訂閱**（月付或年付）時，才會計入里程碑統計
  - 僅完成註冊但未付費的好友**不會**計入 5 人門檻
  - 確保只有真正帶來付費用戶的情況下才發放里程碑獎勵

**二選一機制說明**：
- 如果推薦人先有好友完成首次訂閱，則發放**訂閱獎勵（30天）**，之後即使達到 5 位付費用戶，也不會再發放里程碑獎勵
- 如果推薦人先達到 5 位付費用戶，則發放**里程碑獎勵（1個月免費）**，之後即使有好友完成首次訂閱，也不會再發放訂閱獎勵
- 每個獎勵只能獲得一次，不會重複發放

### 5.2 防止無限累積的機制

#### ✅ **機制設計**

**1. 里程碑獎勵限制**:
```python
def check_milestone_reward(referrer_id: str) -> bool:
    """
    檢查是否應該發放里程碑獎勵
    返回 True 表示應該發放，False 表示已經發放過
    """
    # 檢查是否已經獲得過里程碑獎勵
    if has_received_milestone_reward(referrer_id):
        return False  # 已經獲得過，不再發放
    
    # 檢查是否達到 5 位付費用戶門檻（重要：只計算完成付費訂閱的好友，月付或年付均可）
    paid_referrals_count = count_paid_referrals(referrer_id)
    if paid_referrals_count >= 5:
        return True  # 達到門檻，可以發放
    
    return False  # 未達到門檻
```

**2. 數據庫記錄**:
```sql
-- 在 referral_rewards 表中記錄里程碑獎勵
-- 添加一個標記字段，標記是否為里程碑獎勵
CREATE TABLE IF NOT EXISTS referral_rewards (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    referrer_id TEXT NOT NULL,
    referral_record_id INTEGER NOT NULL,
    reward_type TEXT NOT NULL,  -- 'trial_extension', 'subscription_bonus', 'milestone_reward'
    reward_amount INTEGER NOT NULL,
    description TEXT,
    is_milestone INTEGER DEFAULT 0,  -- 標記是否為里程碑獎勵
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (referrer_id) REFERENCES user_profiles (user_id),
    FOREIGN KEY (referral_record_id) REFERENCES referral_records (id)
);
```

**3. 檢查邏輯**:
```python
def grant_milestone_reward(referrer_id: str) -> bool:
    """
    發放里程碑獎勵
    返回 True 表示成功發放，False 表示已經發放過
    """
    # 檢查是否已經獲得過
    if has_received_milestone_reward(referrer_id):
        logger.info(f"用戶 {referrer_id} 已經獲得過里程碑獎勵，跳過")
        return False
    
    # 檢查是否已經獲得過訂閱獎勵（30天）- 二選一機制
    if has_received_subscription_bonus(referrer_id):
        logger.info(f"用戶 {referrer_id} 已獲得訂閱獎勵（30天），不再發放里程碑獎勵（二選一機制）")
        return False
    
    # 檢查是否達到 5 位付費用戶門檻（重要：只計算完成付費訂閱的好友，月付或年付均可）
    paid_referrals_count = count_paid_referrals(referrer_id)
    if paid_referrals_count < 5:
        logger.info(f"用戶 {referrer_id} 尚未達到 5 位付費用戶門檻（當前：{paid_referrals_count}）")
        return False
    
    # 發放獎勵
    extend_subscription_by_days(referrer_id, 30)
    
    # 記錄到資料庫
    create_referral_reward(
        referrer_id=referrer_id,
        reward_type='milestone_reward',
        reward_amount=30,
        description='累積邀請 5 位付費用戶獎勵（二選一機制）',
        is_milestone=1
    )
    
    # 發送通知
    send_notification(referrer_id, 'milestone_achieved', ...)
    
    return True

def count_paid_referrals(referrer_id: str) -> int:
    """
    計算推薦人有多少位被推薦用戶完成了付費訂閱（月付或年付均可）
    只計算 status='completed' 且 reward_type='subscription_bonus' 的記錄
    注意：月付和年付都算作付費用戶，只要完成訂閱即可計入
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    if use_postgresql:
        cursor.execute("""
            SELECT COUNT(DISTINCT referred_id)
            FROM referral_records
            WHERE referrer_id = %s 
            AND status = 'completed'
            AND reward_type = 'subscription_bonus'
        """, (referrer_id,))
    else:
        cursor.execute("""
            SELECT COUNT(DISTINCT referred_id)
            FROM referral_records
            WHERE referrer_id = ? 
            AND status = 'completed'
            AND reward_type = 'subscription_bonus'
        """, (referrer_id,))
    
    count = cursor.fetchone()[0] or 0
    conn.close()
    return count
```

### 5.3 獎勵累積規則總結

| 獎勵類型 | 觸發條件 | 獎勵內容 | 限制 |
|---------|---------|---------|------|
| **註冊獎勵** | 被推薦用戶完成首次登入 | 7 天免費試用延長 | **無限制**（每邀請一位都可以獲得） |
| **訂閱獎勵** | 被推薦用戶完成首次訂閱 | 30 天使用期限 | **每個被推薦用戶只能觸發一次**<br/>**與里程碑獎勵二選一，先達到條件者優先** |
| **里程碑獎勵** | 累積邀請 **5 位付費用戶**（必須完成付費訂閱，月付或年付均可） | 1 個月免費使用 | **每個推薦人只能獲得一次**（只計算完成付費的好友）<br/>**與訂閱獎勵二選一，先達到條件者優先** |

### 5.4 防止濫用的額外機制

#### 🛡️ **1. 防止自我推薦**
```python
def validate_referral(referrer_id: str, referred_id: str) -> bool:
    """驗證推薦關係是否有效"""
    if referrer_id == referred_id:
        logger.warning(f"用戶 {referrer_id} 嘗試推薦自己")
        return False
    return True
```

#### 🛡️ **2. 防止重複獎勵**
```python
def check_already_rewarded(referrer_id: str, referred_id: str, reward_type: str) -> bool:
    """檢查是否已經發放過特定類型的獎勵"""
    existing = get_referral_reward(referrer_id, referred_id, reward_type)
    return existing is not None
```

#### 🛡️ **3. IP 地址檢查（可選）**
```python
def check_suspicious_activity(referrer_id: str, referred_ip: str) -> bool:
    """檢查是否有可疑活動（同一 IP 多次註冊）"""
    # 記錄 IP，如果同一 IP 註冊過多，標記為可疑
    recent_registrations = count_recent_registrations_by_ip(referred_ip, hours=24)
    if recent_registrations > 3:  # 24 小時內超過 3 次
        logger.warning(f"IP {referred_ip} 在 24 小時內註冊了 {recent_registrations} 次，標記為可疑")
        return True  # 可疑
    return False  # 正常
```

### 5.5 獎勵發放流程圖

```
用戶 A 邀請用戶 B
    ↓
用戶 B 點擊推薦連結並登入
    ↓
檢查推薦關係是否有效
    ↓
記錄推薦關係（referral_records）
    ↓
發放註冊獎勵（7 天）→ 用戶 A
    ↓
用戶 B 完成首次訂閱
    ↓
發放訂閱獎勵（30 天）→ 用戶 A
    ↓
檢查用戶 A 的累積付費用戶數（只計算完成訂閱的好友）
    ↓
如果達到 5 位付費用戶且未獲得過里程碑獎勵
    ↓
發放里程碑獎勵（30 天）→ 用戶 A
    ↓
標記已獲得里程碑獎勵（防止重複發放）
```

---

## 六、實施建議

### 6.1 優先級排序

**第一階段（核心功能）**:
1. ✅ 推薦碼生成和儲存
2. ✅ 推薦關係記錄
3. ✅ 註冊獎勵發放（7 天）
4. ✅ Toast 通知

**第二階段（進階功能）**:
5. ⏳ 訂閱獎勵發放（30 天）
6. ⏳ 里程碑獎勵檢查和發放（1 個月）
7. ⏳ 站內通知系統

**第三階段（優化功能）**:
8. ⏳ Email 通知
9. ⏳ 防作弊機制強化
10. ⏳ 推薦統計和排行榜

### 6.2 測試建議

1. **單元測試**：測試推薦碼生成、獎勵發放邏輯
2. **整合測試**：測試完整的推薦流程
3. **壓力測試**：測試大量並發推薦請求
4. **安全測試**：測試防作弊機制

---

## 七、總結

### 7.1 域名遷移
- ✅ 更新後端 CORS 配置
- ✅ 更新 OAuth 回調 URL
- ✅ 更新環境變數
- ✅ 測試所有功能

### 7.2 使用統計優化
- ✅ 增加更多視覺化圖表
- ✅ 增加對比分析
- ✅ 增加使用說明功能

### 7.3 推薦碼機制
- ✅ 首次登入即生成推薦碼
- ✅ 使用穩定的 hash 算法確保唯一性

### 7.4 通知系統
- ✅ Toast 通知（立即實現）
- ✅ 站內通知系統（數據庫 + API + 前端）
- ⏳ Email 通知（需要配置服務）

### 7.5 獎勵機制
- ✅ 註冊獎勵：無限制
- ✅ 訂閱獎勵：每個被推薦用戶只能觸發一次
- ✅ 里程碑獎勵：每個推薦人只能獲得一次（防止無限累積）

